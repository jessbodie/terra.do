schemaVersion: 3
meta:
  sourceVersionId: 3471b811-4585-4c43-bc9f-85c7640838e0 # DO NOT CHANGE - Hex uses this to match up project versions when reimporting the file
  description: This project taps into the energy stream, fetching and analyzing electricity generation and demand data from the EIA API for a chosen Balancing Authority. It visualizes the grid mix, energy sources, and consumption patterns to provide insights into how weâ€™re keeping the lights on and how much of our electricity is from renewable sources.
  projectId: ede39a0b-fd2b-4797-9189-cd550c1c5dd1 # DO NOT CHANGE - Unique ID of the project from which this file was generated
  title: "Sparking Insights: Electricity Demand and Generation"
  timezone: America/Los_Angeles
  appTheme: SYS_PREF
  codeLanguage: PYTHON
  status:
    name: Completed
  categories:
    - name: Dashboard
  castDecimalsDefault: true
  logicQueryCacheTimeout: null
  publishedQueryCacheTimeout: null
  hexType: PROJECT
  allowExecutionReordering: true
  prerunApp: false
  cachePublishedAppState: true
  refreshStalePublishedApp: false
  autoRerunApp: true
projectAssets:
  dataConnections: []
  envVars: []
  secrets: []
sharedAssets:
  secrets: []
  vcsPackages: []
  dataConnections:
    - dataConnectionId: e8480949-7368-449c-b922-66d0c52bbad0 # Supabase (postgres)
  externalFileIntegrations: []
cells:
  - cellType: CODE
    cellId: b67999c4-053b-42d1-a665-c75331a02748 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Impor Packages
    config:
      source: |-
        import datetime
        import json
        import requests
        from IPython import display
        import pandas as pd
  - cellType: CODE
    cellId: 32544e70-7469-4aa1-954e-95f7a0d47fa7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: EIA API key
    config:
      source: |-
        # EIA API - https://www.eia.gov/opendata/
        EIA_API_KEY = "" # TODO
        assert EIA_API_KEY != "", "You must set an EIA API key before continuing."
  - cellType: CODE
    cellId: d07c3045-4bca-47ea-8f76-2183a676d993 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Data access helper functions by Jaime Curtis and Jason Curtis
    config:
      source: |-
        # Credit:This code written by Jaime Curtis and Jason Curtis
        # Used with permission as part of Terra.do's Software for Climate Online Course (June 2024 Cohort) 
        # 
        # Helper functions you will use to fetch data from the EIA API
        # There are three types of data we're fetching:
        #  1. Generation by fuel type (Megawatt-hours): how much electricity is being generated by each fuel type
        #  2. Demand (Megawatt-hours): how much electricity is being consumed
        #  3. Interchange: how much electricity is being imported/exported from other balancing authorities

        default_end_date = datetime.date.today().isoformat()
        default_start_date = (datetime.date.today() - datetime.timedelta(days=(365*2))).isoformat()

        def get_eia_timeseries(
            url_segment,
            facets,
            value_column_name="value",
            # start_date=default_start_date,
            # end_date=default_end_date,
            # Hard code to easier evaluate seasonality
            start_date=datetime.date(2022, 6, 1).isoformat(),
            end_date=datetime.date(2024, 5, 31).isoformat(),
            start_page=0,
        ):
            """
            A generalized helper function to fetch data from the EIA API
            """

            max_row_count = 5000  # This is the maximum allowed per API call from the EIA
            api_url = f"https://api.eia.gov/v2/electricity/rto/{url_segment}/data/?api_key={EIA_API_KEY}"
            offset = start_page * max_row_count

            response_content = requests.get(
                api_url,
                headers={
                    "X-Params": json.dumps(
                        {
                            "frequency": "daily",
                            "data": ["value"],
                            "facets": dict(**{"timezone": ["Pacific"]}, **facets),
                            "start": start_date,
                            "end": end_date,
                            "sort": [{"column": "period", "direction": "desc"}],
                            "offset": offset,
                            "length": max_row_count,
                        }
                    )
                },
            ).json()

            # Sometimes EIA API responses are nested under a "response" key. Sometimes not ðŸ¤· :lol
            if "response" in response_content:
                response_content = response_content["response"]

            print(f"{len(response_content['data'])} rows fetched")

            # Convert the data to a Pandas DataFrame and clean it up for plotting & analysis.
            dataframe = pd.DataFrame(response_content["data"])
            # Add a more useful timestamp column
            dataframe["timestamp"] = dataframe["period"].apply(
                pd.to_datetime, format="%Y/%m/%dT%H"
            )
            # Clean up the "value" column-
            # EIA always sends the value we asked for in a column called "value"
            # Oddly, this is sometimes sent as a string though it should always be a number.
            # We convert its dtype and set the name to a more useful one
            eia_value_column_name = "value"
            processed_df = dataframe.astype({eia_value_column_name: float}).rename(
                columns={eia_value_column_name: value_column_name}
            )

            # Pagination logic
            rows_fetched = len(processed_df) + offset
            rows_total = int(response_content["total"])
            more_rows_needed = rows_fetched != rows_total
            if more_rows_needed:
                # Recursive call to get remaining rows
                additional_rows = get_eia_timeseries(
                    url_segment=url_segment,
                    facets=facets,
                    value_column_name=value_column_name,
                    start_date=start_date,
                    end_date=end_date,
                    start_page=start_page + 1,
                )
                return pd.concat([processed_df, additional_rows])
            else:
                return processed_df

        def get_eia_timeseries_for_co2_data(
            facets,
            value_column_name="value",
            # start_date=default_start_date,
            # end_date=default_end_date,
            start_page=0,
        ):
            """
            A generalized helper function to fetch data from the EIA API
            """

            max_row_count = 5000  # This is the maximum allowed per API call from the EIA
            api_url = f"https://api.eia.gov/v2/co2-emissions/co2-emissions-aggregates/data/?api_key={EIA_API_KEY}"
            offset = start_page * max_row_count

            response_content = requests.get(
                api_url,
                headers={
                    "X-Params": json.dumps(
                        {
                            "frequency": "annual",
                            "data": ["value"],
                            # "facets": dict(**{"timezone": ["Pacific"]}, **facets),
                            # "start": start_date,
                            # "end": end_date,
                            "sort": [{"column": "period", "direction": "desc"}],
                            "offset": offset,
                            "length": max_row_count,
                        }
                    )
                },
            ).json()

            # Sometimes EIA API responses are nested under a "response" key. Sometimes not ðŸ¤· :lol
            if "response" in response_content:
                response_content = response_content["response"]

            print(f"{len(response_content['data'])} rows fetched")

            # Convert the data to a Pandas DataFrame and clean it up for plotting & analysis.
            dataframe = pd.DataFrame(response_content["data"])
            # Add a more useful timestamp column
            dataframe["timestamp"] = dataframe["period"].apply(
                pd.to_datetime, format="%Y/%m/%dT%H"
            )
            # Clean up the "value" column-
            # EIA always sends the value we asked for in a column called "value"
            # Oddly, this is sometimes sent as a string though it should always be a number.
            # We convert its dtype and set the name to a more useful one
            eia_value_column_name = "value"
            processed_df = dataframe.astype({eia_value_column_name: float}).rename(
                columns={eia_value_column_name: value_column_name}
            )

            # Pagination logic
            rows_fetched = len(processed_df) + offset
            rows_total = int(response_content["total"])
            more_rows_needed = rows_fetched != rows_total
            if more_rows_needed:
                # Recursive call to get remaining rows
                additional_rows = get_eia_timeseries_for_co2_data(
                    # url_segment=url_segment,
                    facets=facets,
                    value_column_name=value_column_name,
                    # start_date=start_date,
                    # end_date=end_date,
                    start_page=start_page + 1,
                )
                return pd.concat([processed_df, additional_rows])
            else:
                return processed_df


        def get_eia_grid_mix_timeseries(balancing_authorities, **kwargs):
            """
            Fetch electricity generation data by fuel type
            """
            return get_eia_timeseries(
                url_segment="daily-fuel-type-data",
                facets={"respondent": balancing_authorities},
                value_column_name="Generation (MWh)",
                **kwargs,
            )

        def get_eia_co2_emissions_timeseries(balancing_authorities, **kwargs):
            """
            Fetch electricity generation data by co2 emissions
            """
            return get_eia_timeseries_for_co2_data(
                facets={"respondent": balancing_authorities},
                value_column_name="value",
                **kwargs,
            )

        def get_eia_net_demand_and_generation_timeseries(balancing_authorities, **kwargs):
            """
            Fetch electricity demand data
            """
            return get_eia_timeseries(
                url_segment="daily-region-data",
                facets={
                    "respondent": balancing_authorities,
                    "type": ["D", "NG", "TI"],  # Filter out the "Demand forecast" (DF) type
                },
                value_column_name="Demand (MWh)",
                **kwargs,
            )


        def get_eia_interchange_timeseries(balancing_authorities, **kwargs):
            """
            Fetch electricity interchange data (imports & exports from other utilities)
            """
            return get_eia_timeseries(
                url_segment="daily-interchange-data",
                facets={"toba": balancing_authorities},
                value_column_name=f"Interchange to local BA (MWh)",
                **kwargs,
            )
  - cellType: MARKDOWN
    cellId: adc2b436-7779-479e-8f79-ad3f3543af31 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: BA Overview
    config:
      source: |-
        A Balancing Authority (BA) is the organization responsible for ensuring electricity generation meets electricity demand in a given region. BAs generate their electricity for local use and typically import or export energy to other connected BAs, as needed.

        Select your local Balancing Authority to update the data and charts in this notebook. 

        If you do not know your local BA, refer to: 
        https://www.eia.gov/electricity/gridmonitor/dashboard/electric_overview/US48/US48
  - cellType: INPUT
    cellId: 402d2c5d-3a83-4b30-b9df-c335603ac524 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Select Your Local BA
    config:
      inputType: DROPDOWN
      name: selected_local_BA
      outputType: STRING
      options:
        valueOptions:
          - YAD - Alcoa Power GeneratingInc. Yadkin Division
          - AZPS - Arizona Public Service Company
          - DEAA - Arlington ValleyLLC
          - AECI - Associated Electric CooperativeInc.
          - AVRN - Avangrid RenewablesLLC
          - AVA - Avista Corporation
          - BANC - Balancing Authority of Northern California
          - BPAT - Bonneville Power Administration
          - CISO - California Independent System Operator
          - HST - City of Homestead
          - TPWR - City of TacomaDepartment of Public UtilitiesLight Division
          - TAL - City of Tallahassee
          - SCEG - Dominion Energy South CarolinaInc.
          - DUK - Duke Energy Carolinas
          - FPC - Duke Energy FloridaInc.
          - CPLE - Duke Energy Progress East
          - CPLW - Duke Energy Progress West
          - EPE - El Paso Electric Company
          - EEI - Electric EnergyInc.
          - ERCO - Electric Reliability Council of TexasInc.
          - FMPP - Florida Municipal Power Pool
          - FPL - Florida Power & Light Co.
          - GVL - Gainesville Regional Utilities
          - GRMA - Gila River PowerLLC
          - GLHB - GridLiance
          - GRID - Gridforce Energy ManagementLLC
          - GRIF - Griffith EnergyLLC
          - ISNE - ISO New England
          - IPCO - Idaho Power Company
          - IID - Imperial Irrigation District
          - JEA - JEA
          - LGEE - Louisville Gas and Electric Company and Kentucky Utilities Company
          - LDWP - Los Angeles Department of Water and Power
          - MISO - Midcontinent Independent System OperatorInc.
          - GWA - NaturEner Power WatchLLC
          - WWA - NaturEner Wind WatchLLC
          - NEVP - Nevada Power Company
          - HGMA - New Harquahala Generating CompanyLLC
          - NYIS - New York Independent System Operator
          - NWMT - NorthWestern Corporation
          - OVEC - Ohio Valley Electric Corporation
          - PJM - PJM InterconnectionLLC
          - DOPD - PUD No. 1 of Douglas County
          - PACE - PacifiCorp East
          - PACW - PacifiCorp West
          - PGE - Portland General Electric Company
          - AEC - PowerSouth Energy Cooperative
          - PSCO - Public Service Company of Colorado
          - PNM - Public Service Company of New Mexico
          - CHPD - Public Utility District No. 1 of Chelan County
          - GCPD - Public Utility District No. 2 of Grant CountyWashington
          - PSEI - Puget Sound EnergyInc.
          - SRP - Salt River Project Agricultural Improvement and Power District
          - SCL - Seattle City Light
          - SEC - Seminole Electric Cooperative
          - SC - South Carolina Public Service Authority
          - SEPA - Southeastern Power Administration
          - SOCO - Southern Company Services Inc. Trans
          - SWPP - Southwest Power Pool
          - SPA - Southwestern Power Administration
          - TEC - Tampa Electric Company
          - TVA - Tennessee Valley Authority
          - TEPC - Tucson Electric Power
          - TIDC - Turlock Irrigation District
          - NSB - Utilities Commission of New Smyrna Beach
          - WALC - Western Area Power Administration Desert Southwest Region
          - WACM - Western Area Power Administration Rocky Mountain Region
          - WAUW - Western Area Power Administration Upper Great Plains West
      defaultValue: NYIS - New York Independent System Operator
  - cellType: CODE
    cellId: a825e967-77fe-420f-89ba-edcc460e4999 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Fetch Energy Usage and Grid Mix from Selected BA
    config:
      source: |-
        
        # Parse selected Local BA
        def parse_BA(selected_BA):
            code, descrip = selected_BA.split(" - ", 1)
            return {"code": code, "descrip": descrip}

        local_BA = parse_BA(selected_local_BA)

        # Request and fetch electricity generation data from the EIA API 
        local_generation_grid_mix = get_eia_grid_mix_timeseries(
            [local_BA['code']]
            # start_date="2022-01-01",
            # end_date="2023-01-01"
        )

        local_generation_grid_mix
  - cellType: MARKDOWN
    cellId: 09bf6c45-8448-4285-9f75-1490a4b21d62 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: |-
        ## What Fuels Are Powering a Balancing Authorityâ€™s Grid Mix? 

        Electric Insight: "grid mix" is the electricity generation breakdown by fuel type (e.g., coal, natural gas, solar, hydro, etc.)
  - cellType: CHARTV2
    cellId: 365165b9-115d-4085-89c9-8991007569d4 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Grid Mix for Selected BA
    config:
      height: 424
      chartSpec:
        type: layered
        layers:
          - id: e66ed52b-79b6-42f5-a753-efe97886e6ca
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " "
              timeUnit: yearmonthdatehours
              dataFrameColumn: timestamp
            series:
              - id: 4c080afe-51ab-4f35-bf94-96a4ec2b9e78
                type: area
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  aggregate: sum
                dataFrameColumns:
                  - Generation (MWh)
                colorDataFrameColumn: type-name
                colorOrder: ascending
                color:
                  type: series
                  colorsBySeriesValues: {}
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: " "
                line: true
                point: false
                normalize: false
            dataFrame: local_generation_grid_mix
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        NG: "#F58518"
        COL: "#4C78A8"
        OIL: "#E45756"
        OTH: "#72B7B2"
        SUN: "#54A24B"
        WAT: "#EECA3B"
        WND: "#B279A2"
        Coal: "#4C78A8"
        Wind: "#B279A2"
        Hydro: "#F58518"
        Other: "#72B7B2"
        Solar: "#EECA3B"
        Demand: "#F58518"
        Nuclear: "#54A24B"
        Unknown: "#FF9DA6"
        Petroleum: "#54A24B"
        Natural Gas: "#E45756"
        Natural gas: "#E45756"
        Net generation: "#E45756"
        Total interchange: "#72B7B2"
        Day-ahead demand forecast: "#4C78A8"
      resultVariable: filter_result_2
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: CODE
    cellId: b2570797-eb5a-4d19-97b7-7451dd88c2b6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: "Combine: Energy consumed locally, broken down by source BA (local and imported) by Jaime Curtis and Jason Curtis"
    config:
      source: |-
        # Credit: This code written by Jaime Curtis and Jason Curtis
        # Used with permission as part of Terra.do's Software for Climate Online Course (June 2024 Cohort) 
        # 
        # DOMAIN KNOWLEDGE AND TERMINOLOGY
        # 
        # Demand (D): energy consumed locally
        # Net generation (NG): energy generated locally
        # Total interchange (TI): net energy exported (positive means net outflow, negative means net inflow)
        # 
        # The balancing authority is responsible for balancing this equation:
        # Total interchange = Net generation - Demand
        # i.e. if local generation is larger than local demand, the BA is exporting electricity (positive total interchange). 
        # If local demand is larger than local generation, the BA is importing electricity (negative total interchange)
        # 
        # To get a true representation of the grid mix of local energy, combine these pieces of data:
        # Demand, Net generation, and Total interchange for the local balancing authority 
        # Interchange (quantity of imported energy) with each connected balancing authority
        # Grid mix of imported energy from each connected balancing authority
        # 
        # 
        # In the code below, we fetch the daily Demand (D), Net generation (NG), and Total interchange (TI) numbers for the LOCAL_BALANCING_AUTHORITY
        # You should see three rows for each date, one row each for TI, D, and NG.
        # You can spot check a given day to confirm that TI = NG - D
        demand_df = get_eia_net_demand_and_generation_timeseries([local_BA['code']])
        interchange_df = get_eia_interchange_timeseries([local_BA['code']])


        # How much energy is both generated and consumed locally
        def get_energy_generated_and_consumed_locally(df):
            demand_stats = df.groupby("type-name")["Demand (MWh)"].sum()
            # If local demand is smaller than net (local) generation, that means: amount generated and used locally == Demand (net export)
            # If local generation is smaller than local demand, that means: amount generated and used locally == Net generation (net import)
            # Therefore, the amount generated and used locally is the minimum of these two
            try:
                return min(demand_stats["Demand"], demand_stats["Net generation"])
            except KeyError:
                # Sometimes for a particular timestamp we're missing demand or net generation. Be conservative and set it to zero
                print(f'Warning - either Demand or Net generation is missing from this timestamp. Values found for "type-name": {list(demand_stats.index)}')
                return 0


        energy_generated_and_used_locally = demand_df.groupby("timestamp").apply(
            get_energy_generated_and_consumed_locally
        )

        consumed_locally_column_name = "Power consumed locally (MWh)"

        # How much energy is imported and then used locally, grouped by the source BA (i.e. the BA which generated the energy)
        energy_imported_then_consumed_locally_by_source_ba = (
            interchange_df.groupby(["timestamp", "fromba"])[
                "Interchange to local BA (MWh)"
            ].sum()
            # We're only interested in data points where energy is coming *in* to the local BA, i.e. where net export is negative
            # Therefore, ignore positive net exports
            .apply(lambda interchange: max(interchange, 0))
        )

        # Combine these two together to get all energy used locally, grouped by the source BA (both local and connected)
        energy_consumed_locally_by_source_ba = pd.concat(
            [
                energy_imported_then_consumed_locally_by_source_ba.rename(
                    consumed_locally_column_name
                ).reset_index("fromba"),
                pd.DataFrame(
                    {
                        "fromba": local_BA['code'],
                        consumed_locally_column_name: energy_generated_and_used_locally,
                    }
                ),
            ]
        ).reset_index()


        # Now that we know how much (if any) energy is imported by our local BA, and from which source BAs,
        # let's get a full breakdown of the grid mix (fuel types) for that imported energy

        # First, get a list of all source BAs: our local BA plus the ones we're importing from
        all_source_bas = energy_consumed_locally_by_source_ba["fromba"].unique().tolist()

        # Then, fetch the fuel type breakdowns for each of those BAs
        generation_types_by_ba = get_eia_grid_mix_timeseries(all_source_bas).rename(
            {"respondent": "fromba", "type-name": "generation_type"}, axis="columns"
        )


        # Combine Demand, Net generation, and Total interchange and Interchange (import or export) 
        #  The goal is to get a DataFrame of energy used at the local BA (in MWh), broken down by both
        #  * the BA that the energy came from, and 
        #  * the fuel type of that energy.
        # Combine the amount of imported energy from each source ba with grid mix for that source BA.
        # Power consumed locally from a (BA, fuel type) combination = 
        #    total power consumed locally from this source BA * (fuel type as a % of source BA's generation)
        # fuel type as a % of source BA's generation = 
        #    (total generation at source BA) / (total generation for this fuel type at this BA)


        total_generation_by_source_ba = generation_types_by_ba.groupby(["timestamp", "fromba"])[
            "Generation (MWh)"
        ].sum()

        generation_types_by_ba_with_totals = generation_types_by_ba.join(
            total_generation_by_source_ba,
            how="left",
            on=["timestamp", "fromba"],
            rsuffix=" Total",
        )
        generation_types_by_ba_with_totals["Generation (% of BA generation)"] = (
            generation_types_by_ba_with_totals["Generation (MWh)"]
            / generation_types_by_ba_with_totals["Generation (MWh) Total"]
        )
        generation_types_by_ba_with_totals_and_source_ba_breakdown = generation_types_by_ba_with_totals.merge(
            energy_consumed_locally_by_source_ba.rename(
                {"Power consumed locally (MWh)": "Power consumed locally from source BA (MWh)"},
                axis="columns",
            ),
            on=["timestamp", "fromba"],
        )
        full_df_reindexed = (
            generation_types_by_ba_with_totals_and_source_ba_breakdown.set_index(
                ["timestamp", "fromba", "generation_type"]
            )
        )
        usage_by_ba_and_generation_type = (
            (
                full_df_reindexed["Power consumed locally from source BA (MWh)"]
                * full_df_reindexed["Generation (% of BA generation)"]
            )
            .rename("Usage (MWh)")
            .reset_index()
        )
        usage_by_ba_and_generation_type
  - cellType: CODE
    cellId: f33e76be-3e92-4dd0-94ed-26007d09d070 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: "Fetch data: Demand, Net generation, and Total interchange"
    config:
      source: demand_df
  - cellType: CODE
    cellId: 4965cfae-d594-46a0-9e2c-c8a3e5649be7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: "Fetch data: Interchange (import or export) with each connected BA"
    config:
      source: interchange_df
  - cellType: MARKDOWN
    cellId: 1be96583-49b4-4dfd-b189-1274d3b71182 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: |
        ## Who's Powering the Grid? 
        #### A Look at the Balancing Authorities Behind the Charge
  - cellType: CODE
    cellId: 14085ef7-f114-409b-8e3d-41d2af4f10da # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: energy_consumed_locally_by_source_ba
  - cellType: CHARTV2
    cellId: c3aa554b-dd1f-4a8e-8ec4-a03a14d0d734 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Energy Consumed by Source BA
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: a84be1bf-fa1e-4b97-97d0-6a2da364421d
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " "
              timeUnit: yearmonthdatehours
              dataFrameColumn: timestamp
            series:
              - id: a2e011f8-d5de-4eb4-b586-7701a5f2f3b5
                type: area
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                dataFrameColumns:
                  - Power consumed locally (MWh)
                colorDataFrameColumn: fromba
                colorOrder: ascending
                color:
                  type: series
                  colorsBySeriesValues: {}
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: " "
                line: true
                point: false
                normalize: false
            dataFrame: energy_consumed_locally_by_source_ba
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        SC: "#E45756"
        AVA: "#B279A2"
        DUK: "#F58518"
        PGE: "#FF9DA6"
        PJM: "#E45756"
        PNM: "#4C78A8"
        SCL: "#54A24B"
        TEX: "#F58518"
        AVRN: "#FF9DA6"
        AZPS: "#F58518"
        BANC: "#9D755D"
        BPAT: "#4C78A8"
        CENT: "#4C78A8"
        CHPD: "#F58518"
        CISO: "#BAB0AC"
        CPLE: "#4C78A8"
        DOPD: "#4C78A8"
        GCPD: "#E45756"
        GRID: "#F58518"
        IPCO: "#E45756"
        ISNE: "#4C78A8"
        LDWP: "#72B7B2"
        NEVP: "#54A24B"
        NWMT: "#EECA3B"
        NYIS: "#F58518"
        PACE: "#72B7B2"
        PACW: "#B279A2"
        PSEI: "#72B7B2"
        SCEG: "#72B7B2"
        SEPA: "#54A24B"
        SOCO: "#EECA3B"
        SWPP: "#E45756"
        TPWR: "#EECA3B"
        WACM: "#72B7B2"
        WALC: "#EECA3B"
        ISNE - ISO New England: "#4C78A8"
        NEVP - Nevada Power Company: "#F58518"
        PSEI - Puget Sound EnergyInc.: "#72B7B2"
        PSCO - Public Service Company of Colorado: "#F58518"
        NYIS - New York Independent System Operator: "#F58518"
        LDWP - Los Angeles Department of Water and Power: "#E45756"
      resultVariable: filter_result_5
      outputResult: true
      displayType: CHART
      displayTableConfig:
        pageSize: 50
        height: null
        hideIcons: false
        defaultColumnWidth: null
        hideIndex: false
        defaultSortColumn: null
        defaultSortIndexColumn: null
        defaultSortDirection: ASC
        conditionalFormatting: null
        calcs: null
        filters: []
        columnProperties:
          - originalName: Power consumed locally (MWh)
            renameTo: null
            size: 223
            wrapText: null
            displayFormat: null
          - originalName: fromba
            renameTo: null
            size: 94
            wrapText: null
            displayFormat: null
          - originalName: timestamp
            renameTo: null
            size: 156
            wrapText: null
            displayFormat: null
        columnOrdering: null
        customColumnOrdering: null
        pinnedColumns: null
        hiddenColumns: null
        pinIndexColumns: false
        showAggregations: false
        columnAggregations: null
  - cellType: MARKDOWN
    cellId: e26acdee-5013-4202-a351-b31e438c124b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: |-
        ## Whatâ€™s Fueling the Flow? 
        #### A Look at Energy Sources from All Local BAs 
  - cellType: CHARTV2
    cellId: 8f259897-f450-4238-9aa5-ab048d0625db # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Grid Mix and Electricity Usage from Local and External BAs
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: d2bad689-88ec-4e03-81d8-11758f0b7c69
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " "
              dataFrameColumn: timestamp
            series:
              - id: e6dcca71-c67f-4e71-9fa8-c236bd380740
                type: area
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  aggregate: sum
                dataFrameColumns:
                  - Usage (MWh)
                colorDataFrameColumn: generation_type
                colorOrder: ascending
                color:
                  type: series
                  colorsBySeriesValues: {}
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: " "
                line: true
                point: false
                normalize: false
            dataFrame: usage_by_ba_and_generation_type
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        Coal: "#4C78A8"
        Wind: "#FF9DA6"
        Hydro: "#F58518"
        Other: "#54A24B"
        Solar: "#B279A2"
        Nuclear: "#72B7B2"
        Unknown: "#9D755D"
        Petroleum: "#EECA3B"
        Natural Gas: "#E45756"
        Natural gas: "#E45756"
      resultVariable: chart_result
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: MARKDOWN
    cellId: 66d844c5-838c-471c-86a0-6a43c9e72537 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: "## Is My Power Clean, Fossil-Fueled, or Somewhere in Between?"
  - cellType: CODE
    cellId: f44ba88e-e191-4f91-9cfc-fa8fb7c7d282 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Simplify Data by Exernal/Internal BA and Energy Source Type
    config:
      source: |
        # Simplify data: 
        # Is energy from Local or External BA?
        # Is energy source of type Renewable, Fossil, or Other? 
        usage_ba_type_simple = usage_by_ba_and_generation_type
        usage_ba_type_simple['ba'] = usage_ba_type_simple['fromba'].where(usage_ba_type_simple['fromba'] == local_BA['code'], other='External BA')
        usage_ba_type_simple['generation_category'] = usage_ba_type_simple['generation_type'].replace({
            'Wind': 'Renewable',
            'Solar': 'Renewable',
            'Hydro': 'Renewable',
            'Petroleum': 'Fossil Fuels',
            'Natural gas': 'Fossil Fuels',
            'Natural Gas': 'Fossil Fuels',
            'Coal': 'Fossil Fuels',
            'Nuclear': 'Nuclear/Other',
            'Other': 'Nuclear/Other'
        })

        usage_ba_type_simple.head(30)
  - cellType: CHARTV2
    cellId: 6c8083af-56fe-4325-ab13-3e2f77e372c9 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Visualization of Energy from Renewable, Fossil Fuels, and Other SourcesÂ  (MWh)
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: 85b07bb5-e332-4e27-8096-748fb7daba96
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " 2022-2024"
              dataFrameColumn: timestamp
            series:
              - id: e17d2600-2a98-4936-9d57-c569feed5a44
                type: area
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  aggregate: sum
                dataFrameColumns:
                  - Usage (MWh)
                colorDataFrameColumn: generation_category
                colorOrder: ascending
                color:
                  type: series
                  colorsBySeriesValues:
                    Renewable: "#54A24B"
                    Fossil Fuels: "#B279A2"
                    Nuclear/Other: "#BAB0AC"
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: " "
                line: true
                point: false
                interpolate: linear
                normalize: false
            dataFrame: usage_ba_type_simple
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        Coal: "#4C78A8"
        Hmmm: "#F58518"
        NYIS: "#F58518"
        Wind: "#FF9DA6"
        "null": "#72B7B2"
        Hydro: "#F58518"
        Other: "#54A24B"
        Solar: "#B279A2"
        Nuclear: "#72B7B2"
        Unknown: "#72B7B2"
        Petroleum: "#EECA3B"
        Renewable: "#E45756"
        External BA: "#4C78A8"
        Natural gas: "#E45756"
        Fossil Fuels: "#4C78A8"
        Nuclear/Other: "#F58518"
      resultVariable: chart_result_4
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: CODE
    cellId: a6950048-b594-48fe-8377-4ad1e6143acb # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Prepare data set from Generation Categories by MWh and as a Percentage of Total Usage
    config:
      source: |-
        # Prepare usage by generation category, both as MWh and percentage of total usage
        # Group by timestamp and sum Usage (MWh) for each generation category
        usage_by_category = usage_ba_type_simple.groupby(['timestamp', 'generation_category']).agg(
            subtotal_usage=('Usage (MWh)', 'sum')
        ).reset_index()

        # Calculate the total usage per day
        daily_total_usage = usage_by_category.groupby('timestamp').agg(
            total_usage_daily=('subtotal_usage', 'sum') 
        ).reset_index()

        # Merge the total daily usage back with the original usage_by_category dataframe
        usage_by_category = usage_by_category.merge(daily_total_usage, on='timestamp', how='left')

        # Calculate the percentage of usage for each generation category
        usage_by_category['usage_percentage'] = (usage_by_category['subtotal_usage'] / usage_by_category['total_usage_daily']) * 100

        usage_by_category
  - cellType: CHARTV2
    cellId: 8698ff18-769f-4a08-8c07-3eddbd101db8 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Visualization of Energy from Renewable, Fossil Fuels, and Other Sources as a Percentage
    config:
      height: null
      chartSpec:
        type: layered
        facet: {}
        layers:
          - id: 8a13b84c-c583-414d-98dc-d2ff57ed9665
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " 2022-2024"
              dataFrameColumn: timestamp
            series:
              - id: 7c571772-6e76-4316-a9cb-e3cc92585cda
                type: area
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  title: Percentage of Total
                dataFrameColumns:
                  - usage_percentage
                colorDataFrameColumn: generation_category
                colorOrder: ascending
                color:
                  type: series
                  dataType: number
                  colorsBySeriesValues:
                    Renewable: "#54A24B"
                    Fossil Fuels: "#B279A2"
                    Nuclear/Other: "#BAB0AC"
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: Â 
                line: true
                point: false
                normalize: false
            dataFrame: usage_by_category
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        Renewable: "#E45756"
        Fossil Fuels: "#4C78A8"
        Nuclear/Other: "#F58518"
      resultVariable: chart_result_11
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: MARKDOWN
    cellId: e166122f-dd2f-4622-beae-53a6108c86fb # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: "## Alternating Currents: The Fluctuations in Electricity Consumption"
  - cellType: CODE
    cellId: e512299b-951a-4447-9e64-60771cad26a0 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Clean and Smooth Daily Electricity Usage
    config:
      source: |-
        # Simplify to show full 'Usage (MWh)' by day
        daily_usage = usage_ba_type_simple.groupby('timestamp')['Usage (MWh)'].sum().reset_index()

        # Filter 'Usage (MWh)' to show only when there is MWh data
        daily_usage['Filtered Usage (MWh)'] = daily_usage['Usage (MWh)'].where(daily_usage['Usage (MWh)'] > 0)

        # Calculate average daily usage across all days, prepare to show in chart
        avg_daily_usage = daily_usage['Filtered Usage (MWh)'].mean()
        daily_usage['Average Usage (MWh)'] = daily_usage['Filtered Usage (MWh)'].mean() 

        # Calculate the simple moving average (SMA) over specified number of days
        window_size = 15 
        daily_usage['Simple Moving Average (MWh)'] = daily_usage['Filtered Usage (MWh)'].rolling(window=window_size, center=True).mean()

        daily_usage
  - cellType: CHARTV2
    cellId: 65990d50-8007-4765-8e7a-1f39388d44b1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Visualization of Load Patterns  for Selected BA
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: f788c687-d6fd-46c1-ad20-843b06b0c884
            xAxis:
              type: datetime
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              title: " 2022-2024"
              dataFrameColumn: timestamp
            series:
              - id: 0cc7ae27-b612-401b-b658-4d1bcf84e5eb
                type: line
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  title: Usage (MWh)
                dataFrameColumns:
                  - Filtered Usage (MWh)
                colorOrder: ascending
                color:
                  type: static
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                point: false
                stroke: solid
                width: 1
              - id: 9609c440-12e5-4e69-8648-50cba36033b3
                type: line
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  title: Usage (MWh)
                dataFrameColumns:
                  - Average Usage (MWh)
                colorOrder: ascending
                color:
                  type: static
                  color: "#54A24B"
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                point: false
                stroke: solid
                width: 1
              - id: 1ff6b920-679b-44e0-a90f-671eadc501b3
                type: line
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                  title: Usage (MWh)
                dataFrameColumns:
                  - Simple Moving Average (MWh)
                colorOrder: ascending
                color:
                  type: static
                  color: "#72B7B2"
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                point: false
                stroke: solid
                width: 3
            dataFrame: daily_usage
            seriesGroups:
              - - 0cc7ae27-b612-401b-b658-4d1bcf84e5eb
                - 9609c440-12e5-4e69-8648-50cba36033b3
                - 1ff6b920-679b-44e0-a90f-671eadc501b3
        settings:
          legend:
            position: bottom-left
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings: {}
      resultVariable: chart_result_9
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: CODE
    cellId: ea996357-a82b-4fdf-ac5b-62a28c514bf2 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Identify Peak Period Start and End Dates, Get Usage (MWh) for Each Period, Summarize for Each PeriodÂ Â 
    config:
      source: |-
        # Find start and end dates of all peak periods
        peak_period_dates = []
        peak_days_min = 10

        # Handle for when a data set begins when a peak usage period has already begun
        SMA_index_centered = 7
        first_SMA_day = (daily_usage['Simple Moving Average (MWh)'][SMA_index_centered])
        cross_up_dates = []
        if first_SMA_day > avg_daily_usage:
            cross_up_dates.append(daily_usage.iloc[SMA_index_centered]['timestamp'].strftime('%Y-%m-%d'))

        # Detect cross-up (SMA crosses above avg_daily_usage)
        daily_usage['Cross_Up'] = (daily_usage['Simple Moving Average (MWh)'].shift(1) < avg_daily_usage) & (daily_usage['Simple Moving Average (MWh)'] > avg_daily_usage)
        # Detect cross-down (SMA crosses below avg_daily_usage)
        daily_usage['Cross_Down'] = (daily_usage['Simple Moving Average (MWh)'].shift(1) > avg_daily_usage) & (daily_usage['Simple Moving Average (MWh)'] < avg_daily_usage)
        # Extract dates when the cross happens
        cross_up_dates = cross_up_dates + (daily_usage.loc[daily_usage['Cross_Up'], 'timestamp'].dt.strftime('%Y-%m-%d').tolist())
        cross_down_dates = daily_usage.loc[daily_usage['Cross_Down'], 'timestamp'].dt.strftime('%Y-%m-%d').tolist()

        # Handle for when a data set ends when a peak usage period is beginning
        if (len(cross_up_dates) == (len(cross_down_dates) + 1)):
            cross_down_dates.append(daily_usage.iloc[(SMA_index_centered * -1)]['timestamp'].strftime('%Y-%m-%d'))

        # Pair start and end dates into a list
        for cross_up_date, cross_down_date in zip(cross_up_dates, cross_down_dates):
            peak_start_end = (cross_up_date, cross_down_date)
            peak_num_days = abs((pd.to_datetime(cross_up_date, format="%Y-%m-%d") - pd.to_datetime(cross_down_date, format="%Y-%m-%d")))
            if (peak_num_days.days >= peak_days_min):
                peak_period_dates.append(peak_start_end)


        # Prepare data that is off-peak (excludes peak date ranges) 
        # Create a boolean mask for data within cross_up and cross_down ranges
        mask = pd.Series(False, index=daily_usage.index)
        for up_date, down_date in zip(cross_up_dates, cross_down_dates):
            mask |= (daily_usage['timestamp'] >= up_date) & (daily_usage['timestamp'] <= down_date)
        # Invert the mask to get data outside those ranges
        outside_ranges_data = daily_usage[~mask]

        off_peak_subset = outside_ranges_data['Filtered Usage (MWh)']

        # Filter the MWh based on the period's date range
        def get_MWh(periods_dates):
            period_data = daily_usage[(daily_usage['timestamp'] >= periods_dates[0]) & (daily_usage['timestamp'] <= periods_dates[1])]
            filtered_usage_mwh = period_data['Filtered Usage (MWh)']
            return filtered_usage_mwh

        # Prepare summary of data for each period
        def summarize_period_MWh(period_dates, subset):
            if isinstance(period_dates, str):
                label = period_dates
            else:
                label = 'Peak: ' + period_dates[0] + ' - ' + period_dates[1]
            new_summary = {
                'Period': label,
                'Average Usage (MWh)': round(subset.mean(), 0),
                'Minimum Usage (MWh)': round(subset.min(), 0),
                'Maximum Usage (MWh)': round(subset.max(), 0)
            }
            return new_summary

        # For each peak period, get associated MWh, and prepare summary for each period 
        summaries_all_periods = []
        for peak_period_date in peak_period_dates:
            peak_subset = get_MWh(peak_period_date)
            summary_period = summarize_period_MWh(peak_period_date, peak_subset)
            summaries_all_periods.append(summary_period)


        off_peak_label_display = 'Average Off-Peak'
        off_peak_summary = summarize_period_MWh(off_peak_label_display, off_peak_subset)
        summaries_all_periods.append(off_peak_summary)


        summaries_all_periods_df = pd.DataFrame(summaries_all_periods) 
        tidy_summaries_df = pd.melt(summaries_all_periods_df, id_vars='Period', var_name='Summary Type', value_name='Usage (MWh)')

        summaries_all_periods_df
  - cellType: CHARTV2
    cellId: 13fe8a08-b3b3-4104-8622-222069052485 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: "Visualization of Usage Statistics: Peak and Off-Peak Periods"
    config:
      height: null
      chartSpec:
        type: layered
        facet: {}
        layers:
          - id: dab48110-4c11-40e8-9470-fb0df88693de
            xAxis:
              type: string
              style:
                grid:
                  style: solid
                ticks: {}
                labels:
                  angle: 0
              title: " "
              dataFrameColumn: Period
            series:
              - id: ee3eec3b-3d48-4953-85d1-d0bf8fe28345
                type: bar
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                dataFrameColumns:
                  - Usage (MWh)
                colorDataFrameColumn: Summary Type
                colorOrder: ascending
                color:
                  type: series
                  color: "#F58518"
                  dataType: number
                  colorsBySeriesValues:
                    Average Usage (MWh): "#54A24B"
                    Maximum Usage (MWh): "#4C78A8"
                    Minimum Usage (MWh): "#72B7B2"
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                legendTitle: " "
                barWidth: 1
                orientation: vertical
                layout: grouped
            dataFrame: tidy_summaries_df
        settings:
          legend:
            position: top-left
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings:
        Average Usage (MWh): "#4C78A8"
        Maximum Usage (MWh): "#F58518"
        Minimum Usage (MWh): "#E45756"
      resultVariable: chart_result_10
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: MARKDOWN
    cellId: 9b351146-2d80-41a3-a6c5-3bc3a5600482 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Subhead
    config:
      source: "## How Close Are Renewables to Powering the Grid?"
  - cellType: CODE
    cellId: 08cfa04f-9035-49fd-938d-7d6bff009bae # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Summarize Electricity from Renewable as MWh and as Percentages
    config:
      source: |
        # Function to calculate % increase in renewable energy supply required to meet total usage
        def calc_more_renewable (tot, current):
            percent_more_renewable_needed = round((tot / current) * 100)
            return percent_more_renewable_needed

        # Function to filter the df to get the 'Renewable' row for specified date
        def get_renewable_usage_data(display_label, renewable_data):
            summary_row = [display_label, 
                            round(renewable_data['subtotal_usage'].values[0]),
                            round(renewable_data['total_usage_daily'].values[0]),
                            int(renewable_data['usage_percentage'].values[0]),
                            calc_more_renewable(renewable_data['total_usage_daily'].values[0], renewable_data['subtotal_usage'].values[0])
            ]
            return summary_row

        # Get the averages of the electricity usage from renewable sources 
        renewable_usage = usage_by_category[usage_by_category['generation_category'] == 'Renewable']
        average_renewable_usage = renewable_usage.select_dtypes(include='number').mean()
        average_renewable_usage_df = pd.DataFrame(average_renewable_usage).T

        # Get the data where the 'Filtered Usage (MWh)' is the min value, and Renewable
        min_filtered_usage_row = usage_by_category.loc[usage_by_category['total_usage_daily'].idxmin()]
        min_usage_day = min_filtered_usage_row['timestamp']
        min_filtered_usage_renewable = usage_by_category.loc[
            (usage_by_category['timestamp'] == min_usage_day) & 
            (usage_by_category['generation_category'] == 'Renewable')
        ]
        # Get the date where the 'Filtered Usage (MWh)' is the max value
        max_filtered_usage_row = usage_by_category.loc[usage_by_category['total_usage_daily'].idxmax()]
        max_usage_day = max_filtered_usage_row['timestamp']
        max_filtered_usage_renewable = usage_by_category.loc[
            (usage_by_category['timestamp'] == max_usage_day) & 
            (usage_by_category['generation_category'] == 'Renewable')
        ]

        summary_df = pd.DataFrame([get_renewable_usage_data('Average Day', average_renewable_usage_df)], 
            columns=['Type', 'Renewable Subtotal (MWh)', 'Total Usage (MWh)', '% Current Supply from Renewables',
            '% Increase in Renewables Needed'])

        summary_df.loc[len(summary_df)] = get_renewable_usage_data('Lowest Demand Day', min_filtered_usage_renewable) 
        summary_df.loc[len(summary_df)] = get_renewable_usage_data('Highest Demand Day', max_filtered_usage_renewable) 

        # Prepare for display average day current percentage and percentage increase needed
        average_day_renewables_percentage = str(summary_df.loc[summary_df['Type'] == 'Average Day', '% Current Supply from Renewables'].values[0]) + '%'
        average_day_renewables_percentage_needed = str(summary_df.loc[summary_df['Type'] == 'Average Day', '% Increase in Renewables Needed'].values[0]) + '%'
        summary_df
  - cellType: METRIC
    cellId: e1b1eb23-2eca-4100-8ee4-3d605f897b7a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Electricity Currently Supplied from Renewables (Average Day)
    config:
      title: " "
      valueVariableName: average_day_renewables_percentage
      showComparison: false
      comparisonType: VALUE
      comparisonVariableName: null
      comparisonFormat: null
      comparisonLabel: ""
      displayFormat:
        format: PLAIN
        currency: USD
        columnType: NUMBER
        showSeparators: true
        numDecimalDigits: -1
        abbreviateLargeNumbers: false
      valueColumn: null
      valueRowIndex: null
      valueAggregate: null
      comparisonColumn: null
      comparisonRowIndex: null
      comparisonAggregate: null
      valueResultVariable: value
      comparisonResultVariable: comparison_value
      outputResult: true
  - cellType: METRIC
    cellId: 4efa18d1-d0f2-404b-adc8-e75db888f095 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Increase of Renewable SupplyÂ  Required to Meet Electricity Demand (Average Day)
    config:
      title: " "
      valueVariableName: average_day_renewables_percentage_needed
      showComparison: false
      comparisonType: VALUE
      comparisonVariableName: null
      comparisonFormat: null
      comparisonLabel: ""
      displayFormat:
        format: PLAIN
        currency: USD
        columnType: NUMBER
        showSeparators: true
        numDecimalDigits: -1
        abbreviateLargeNumbers: false
      valueColumn: null
      valueRowIndex: null
      valueAggregate: null
      comparisonColumn: null
      comparisonRowIndex: null
      comparisonAggregate: null
      valueResultVariable: value_2
      comparisonResultVariable: comparison_value
      outputResult: true
  - cellType: CODE
    cellId: 0e1eda63-76de-4c21-a47a-82b6a9be1592 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Summary
    config:
      source: |
        print(f'''BA: {local_BA['descrip']} ({local_BA['code']})''')
  - cellType: CODE
    cellId: 64ea8838-816a-4351-9ecd-91ec46fafb15 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Usage Summary for Renewables (MWh and %)Â 
    config:
      source: |-
        # Add comma delimiters
        summary_df['Renewable Subtotal (MWh)'] = summary_df['Renewable Subtotal (MWh)'].apply(lambda x: '{:,}'.format(x))
        summary_df['Total Usage (MWh)'] = summary_df['Total Usage (MWh)'].apply(lambda x: '{:,}'.format(x))

        # Apply left/center styling to columns 
        summary_df_styled = summary_df.style.set_properties(subset=['Type'], **{'text-align': 'left'})
        summary_df_styled = summary_df_styled.set_properties(subset=['Renewable Subtotal (MWh)', 'Total Usage (MWh)', '% Current Supply from Renewables', '% Increase in Renewables Needed'], 
                          **{'text-align': 'center'})

        summary_df_styled
  - cellType: MARKDOWN
    cellId: 93e3af2a-256f-442c-b1b3-bdc5546919e4 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Break
    config:
      source: _____________________________________________
  - cellType: MARKDOWN
    cellId: a23f6dc9-b531-484a-925d-5b7b2ba0aa43 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Notes & Credits
    config:
      source: |+
        ## Power Sources: Notes & Credits

        Project initially prepared as an assignment for Terra.do's Software for Climate Online Course with Jaime Curtis and Jason Curtis (June 2024 Cohort)

        The data access and energy sources combination code reused with permission from Jaime Curtis and Jason Curtis (Terra.do).

        #### EIA API Dashboard
         * https://www.eia.gov/opendata/browser/electricity/rto/daily-region-data 

        #### Hourly Electric Grid Monitor
         * https://www.eia.gov/electricity/gridmonitor/dashboard/electric_overview/US48/US48

appLayout:
  visibleMetadataFields:
    - NAME
    - DESCRIPTION
    - AUTHOR
    - LAST_EDITED
    - LAST_RUN
    - CATEGORIES
    - STATUS
    - TABLE_OF_CONTENTS
  fullWidth: false
  tabs:
    - name: Balancing Authorities
      rows:
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: adc2b436-7779-479e-8f79-ad3f3543af31
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 75
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 402d2c5d-3a83-4b30-b9df-c335603ac524
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 09bf6c45-8448-4285-9f75-1490a4b21d62
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 365165b9-115d-4085-89c9-8991007569d4
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 1be96583-49b4-4dfd-b189-1274d3b71182
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: c3aa554b-dd1f-4a8e-8ec4-a03a14d0d734
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: e26acdee-5013-4202-a351-b31e438c124b
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 8f259897-f450-4238-9aa5-ab048d0625db
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 93e3af2a-256f-442c-b1b3-bdc5546919e4
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: a23f6dc9-b531-484a-925d-5b7b2ba0aa43
                  sharedFilterId: null
                  height: null
                  showLabel: false
    - name: Energy Sources
      rows:
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 66d844c5-838c-471c-86a0-6a43c9e72537
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 6c8083af-56fe-4325-ab13-3e2f77e372c9
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 8698ff18-769f-4a08-8c07-3eddbd101db8
                  sharedFilterId: null
                  height: null
                  showLabel: true
    - name: Usage Fluctuations
      rows:
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: e166122f-dd2f-4622-beae-53a6108c86fb
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 65990d50-8007-4765-8e7a-1f39388d44b1
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 13fe8a08-b3b3-4104-8622-222069052485
                  sharedFilterId: null
                  height: null
                  showLabel: true
    - name: Renewables Meeting Demand
      rows:
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 9b351146-2d80-41a3-a6c5-3bc3a5600482
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 0e1eda63-76de-4c21-a47a-82b6a9be1592
                  sharedFilterId: null
                  height: null
                  showLabel: false
        - columns:
            - start: 0
              end: 60
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: e1b1eb23-2eca-4100-8ee4-3d605f897b7a
                  sharedFilterId: null
                  height: null
                  showLabel: true
            - start: 60
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 4efa18d1-d0f2-404b-adc8-e75db888f095
                  sharedFilterId: null
                  height: null
                  showLabel: true
        - columns:
            - start: 0
              end: 120
              elements:
                - showSource: false
                  hideOutput: false
                  type: CELL
                  cellId: 64ea8838-816a-4351-9ecd-91ec46fafb15
                  sharedFilterId: null
                  height: null
                  showLabel: true
sharedFilters: []
